using System;using System.Collections.Generic;using System.Text;using System.Text.RegularExpressions;using RH = Dino.LocalizationKeyGenerator.Editor.Utility.RegexHelper;namespace Dino.LocalizationKeyGenerator.Editor.Utility {    internal class TextFormatter {        private const char DoNotModifyCaseMarker = '*';        private readonly StringBuilder _builder = new StringBuilder();        private static string _splitPattern;        private static string _formatPattern;        public bool CanFormat(Type type) {            return type.IsEnum || type == typeof(string);        }        public string Format(object input, string format) {            if (string.IsNullOrEmpty(format)) {                return input.ToString();            }            return Concat(SplitWords(input.ToString()), format);        }                private List<string> SplitWords(string line) {            var pattern = BuildSplitPattern();            var matches = Regex.Matches(line, pattern);            var words = new List<string>();            for (var i = 0; i < matches.Count; i++) {                if (matches[i].Groups.Count < 2) {                    continue;                }                words.Add(matches[i].Groups[1].Value);            }            return words;        }        private string Concat(IReadOnlyList<string> words, string format) {            var pattern = BuildFormatPattern();            var formatMatch = Regex.Match(format, pattern);            if (formatMatch.Groups.Count != 4) {                throw new FormatException();            }                        var firstWordPattern = formatMatch.Groups[1].Value;            var everyOtherWordPattern = formatMatch.Groups[3].Value;            var separator = formatMatch.Groups[2].Value;            var firstCharInLineCaseModifier = ParseModifier(firstWordPattern[0]);            var firstCharInWordCaseModifier = ParseModifier(everyOtherWordPattern[0]);            var everyOtherCharCaseModifier = ParseModifier(everyOtherWordPattern[everyOtherWordPattern.Length - 1]);            _builder.Clear();            for (var i = 0; i < words.Count; i++) {                var word = words[i];                var firstCharCaseModifier = i == 0 ? firstCharInLineCaseModifier : firstCharInWordCaseModifier;                _builder.Append(ModifyCase(word[0], firstCharCaseModifier));                if (word.Length > 1) {                    _builder.Append(ModifyCase(word.Substring(1), everyOtherCharCaseModifier));                }                if (i < words.Count - 1) {                    _builder.Append(separator);                }            }            return _builder.ToString();        }        private static string BuildFormatPattern() {            if (string.IsNullOrEmpty(_formatPattern) == false) {                return _formatPattern;            }            var marker = Regex.Escape(DoNotModifyCaseMarker.ToString());            var wordFormat = $@"{RH.RepeatExactly(RH.AnyOf(RH.Letter, marker), 2)}|{marker}";            var splitterEndingWithMarker = $"{RH.Not(RH.Letter)}*{marker}";            var splitterEndingWithSymbol = $"{RH.Not(RH.Letter)}*{RH.Not(marker)}";            var emptySplitter = string.Empty;            var splitterFormat = $@"{splitterEndingWithMarker}{RH.NotFollowedBy($"{marker}{RH.End}")}|{splitterEndingWithSymbol}|{emptySplitter}";            _formatPattern = $@"({wordFormat})({splitterFormat})({wordFormat})";            return _formatPattern;        }        private static string BuildSplitPattern() {            if (string.IsNullOrEmpty(_splitPattern) == false) {                return _splitPattern;            }            var wordStartingWithAnyLetter = $"(({RH.UpperCase}{RH.LowerCase}*{RH.Digit}*)|({RH.LowerCase}+{RH.Digit}*)|({RH.Digit}+))";            var wordStartingWithUpperCase = $"{RH.UpperCase}{RH.LowerCase}*{RH.Digit}*";            var upperCaseAcronym = $"{RH.RepeatAtLeast(RH.UpperCase, 2)}{RH.NotFollowedBy(RH.LowerCase)}{RH.Digit}*";            _splitPattern = $"({RH.NotPrecededBy(RH.UpperCase)}({upperCaseAcronym}|{wordStartingWithUpperCase})" +                            $"|{RH.NotPrecededBy(RH.Letter)}{wordStartingWithAnyLetter}|{wordStartingWithUpperCase})";            return _splitPattern;        }        private static CaseModification ParseModifier(char c) {            switch (c) {                case DoNotModifyCaseMarker: return CaseModification.None;                case var _ when char.IsUpper(c): return CaseModification.ToUpper;                default: return CaseModification.ToLower;            }        }        private static string ModifyCase(char c, CaseModification modifier) {            return ModifyCase(c.ToString(), modifier);        }        private static string ModifyCase(string str, CaseModification modifier) {            switch (modifier) {                case CaseModification.None: return str;                case CaseModification.ToUpper: return str.ToUpper();                default: return str.ToLower();            }        }        private enum CaseModification {            None = 0,            ToUpper = 1,            ToLower = 2        }    }}